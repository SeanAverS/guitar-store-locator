/*! For license information please see 237.e7e4f69d.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkguitar_store_locator=self.webpackChunkguitar_store_locator||[]).push([[237],{122:t=>{t.exports=function t(e,s){if(e===s)return!0;if(e&&s&&"object"==typeof e&&"object"==typeof s){if(e.constructor!==s.constructor)return!1;var r,o,i;if(Array.isArray(e)){if((r=e.length)!=s.length)return!1;for(o=r;0!==o--;)if(!t(e[o],s[o]))return!1;return!0}if(e.constructor===RegExp)return e.source===s.source&&e.flags===s.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===s.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===s.toString();if((r=(i=Object.keys(e)).length)!==Object.keys(s).length)return!1;for(o=r;0!==o--;)if(!Object.prototype.hasOwnProperty.call(s,i[o]))return!1;for(o=r;0!==o--;){var n=i[o];if(!t(e[n],s[n]))return!1}return!0}return e!==e&&s!==s}},237:(t,e,s)=>{s.r(e),s.d(e,{AbstractAlgorithm:()=>O,AbstractViewportAlgorithm:()=>I,Cluster:()=>P,ClusterStats:()=>B,DefaultRenderer:()=>D,GridAlgorithm:()=>S,MarkerClusterer:()=>$,MarkerClustererEvents:()=>F,MarkerUtils:()=>M,NoopAlgorithm:()=>j,SuperClusterAlgorithm:()=>z,SuperClusterViewportAlgorithm:()=>U,defaultOnClusterClickHandler:()=>R,distanceBetweenPoints:()=>E,extendBoundsToPaddedViewport:()=>_,extendPixelBounds:()=>L,filterMarkersToPaddedViewport:()=>C,getPaddedViewport:()=>A,noop:()=>T,pixelBoundsToLatLngBounds:()=>Z});var r=s(122),o=s.n(r);const i=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class n{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,s]=new Uint8Array(t,0,2);if(219!==e)throw new Error("Data does not appear to be in a KDBush format.");const r=s>>4;if(1!==r)throw new Error(`Got v${r} data when expected v1.`);const o=i[15&s];if(!o)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(t,2,1),[h]=new Uint32Array(t,4,1);return new n(h,a,o,t)}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:64,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Float64Array,r=arguments.length>3?arguments[3]:void 0;if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=s,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const o=i.indexOf(this.ArrayType),n=2*t*this.ArrayType.BYTES_PER_ELEMENT,a=t*this.IndexArrayType.BYTES_PER_ELEMENT,h=(8-a%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${s}.`);r&&r instanceof ArrayBuffer?(this.data=r,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+h,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+n+a+h),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+h,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+o]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return a(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:i,nodeSize:n}=this,a=[0,o.length-1,0],h=[];for(;a.length;){const c=a.pop()||0,l=a.pop()||0,u=a.pop()||0;if(l-u<=n){for(let n=u;n<=l;n++){const a=i[2*n],c=i[2*n+1];a>=t&&a<=s&&c>=e&&c<=r&&h.push(o[n])}continue}const p=u+l>>1,m=i[2*p],d=i[2*p+1];m>=t&&m<=s&&d>=e&&d<=r&&h.push(o[p]),(0===c?t<=m:e<=d)&&(a.push(u),a.push(p-1),a.push(1-c)),(0===c?s>=m:r>=d)&&(a.push(p+1),a.push(l),a.push(1-c))}return h}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:r,coords:o,nodeSize:i}=this,n=[0,r.length-1,0],a=[],h=s*s;for(;n.length;){const c=n.pop()||0,l=n.pop()||0,p=n.pop()||0;if(l-p<=i){for(let s=p;s<=l;s++)u(o[2*s],o[2*s+1],t,e)<=h&&a.push(r[s]);continue}const m=p+l>>1,d=o[2*m],g=o[2*m+1];u(d,g,t,e)<=h&&a.push(r[m]),(0===c?t-s<=d:e-s<=g)&&(n.push(p),n.push(m-1),n.push(1-c)),(0===c?t+s>=d:e+s>=g)&&(n.push(m+1),n.push(l),n.push(1-c))}return a}}function a(t,e,s,r,o,i){if(o-r<=s)return;const n=r+o>>1;h(t,e,n,r,o,i),a(t,e,s,r,n-1,1-i),a(t,e,s,n+1,o,1-i)}function h(t,e,s,r,o,i){for(;o>r;){if(o-r>600){const n=o-r+1,a=s-r+1,c=Math.log(n),l=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*l*(n-l)/n)*(a-n/2<0?-1:1);h(t,e,s,Math.max(r,Math.floor(s-a*l/n+u)),Math.min(o,Math.floor(s+(n-a)*l/n+u)),i)}const n=e[2*s+i];let a=r,l=o;for(c(t,e,r,s),e[2*o+i]>n&&c(t,e,r,o);a<l;){for(c(t,e,a,l),a++,l--;e[2*a+i]<n;)a++;for(;e[2*l+i]>n;)l--}e[2*r+i]===n?c(t,e,r,l):(l++,c(t,e,l,o)),l<=s&&(r=l+1),s<=l&&(o=l-1)}}function c(t,e,s,r){l(t,s,r),l(e,2*s,2*r),l(e,2*s+1,2*r+1)}function l(t,e,s){const r=t[e];t[e]=t[s],t[s]=r}function u(t,e,s,r){const o=t-s,i=e-r;return o*o+i*i}const p={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},m=Math.fround||(d=new Float32Array(1),t=>(d[0]=+t,d[0]));var d;class g{constructor(t){this.options=Object.assign(Object.create(p),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:s,maxZoom:r}=this.options;e&&console.time("total time");const o=`prepare ${t.length} points`;e&&console.time(o),this.points=t;const i=[];for(let a=0;a<t.length;a++){const e=t[a];if(!e.geometry)continue;const[s,r]=e.geometry.coordinates,o=m(w(s)),n=m(y(r));i.push(o,n,1/0,a,-1,1),this.options.reduce&&i.push(0)}let n=this.trees[r+1]=this._createTree(i);e&&console.timeEnd(o);for(let a=r;a>=s;a--){const t=+Date.now();n=this.trees[a]=this._createTree(this._cluster(n,a)),e&&console.log("z%d: %d clusters in %dms",a,n.numItems,+Date.now()-t)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,t[1]));let o=180===t[2]?180:((t[2]+180)%360+360)%360-180;const i=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,o=180;else if(s>o){const t=this.getClusters([s,r,180,i],e),n=this.getClusters([-180,r,o,i],e);return t.concat(n)}const n=this.trees[this._limitZoom(e)],a=n.range(w(s),y(i),w(o),y(r)),h=n.data,c=[];for(const l of a){const t=this.stride*l;c.push(h[t+5]>1?f(h,t,this.clusterProps):this.points[h[t+3]])}return c}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),r="No cluster with the specified id.",o=this.trees[s];if(!o)throw new Error(r);const i=o.data;if(e*this.stride>=i.length)throw new Error(r);const n=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=i[e*this.stride],h=i[e*this.stride+1],c=o.within(a,h,n),l=[];for(const u of c){const e=u*this.stride;i[e+4]===t&&l.push(i[e+5]>1?f(i,e,this.clusterProps):this.points[i[e+3]])}if(0===l.length)throw new Error(r);return l}getLeaves(t,e,s){e=e||10,s=s||0;const r=[];return this._appendLeaves(r,t,e,s,0),r}getTile(t,e,s){const r=this.trees[this._limitZoom(t)],o=Math.pow(2,t),{extent:i,radius:n}=this.options,a=n/i,h=(s-a)/o,c=(s+1+a)/o,l={features:[]};return this._addTileFeatures(r.range((e-a)/o,h,(e+1+a)/o,c),r.data,e,s,o,l),0===e&&this._addTileFeatures(r.range(1-a/o,h,1,c),r.data,o,s,o,l),e===o-1&&this._addTileFeatures(r.range(0,h,a/o,c),r.data,-1,s,o,l),l.features.length?l:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,1!==s.length)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,r,o){const i=this.getChildren(e);for(const n of i){const e=n.properties;if(e&&e.cluster?o+e.point_count<=r?o+=e.point_count:o=this._appendLeaves(t,e.cluster_id,s,r,o):o<r?o++:t.push(n),t.length===s)break}return o}_createTree(t){const e=new n(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<t.length;s+=this.stride)e.add(t[s],t[s+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,s,r,o,i){for(const n of t){const t=n*this.stride,a=e[t+5]>1;let h,c,l;if(a)h=k(e,t,this.clusterProps),c=e[t],l=e[t+1];else{const s=this.points[e[t+3]];h=s.properties;const[r,o]=s.geometry.coordinates;c=w(r),l=y(o)}const u={type:1,geometry:[[Math.round(this.options.extent*(c*o-s)),Math.round(this.options.extent*(l*o-r))]],tags:h};let p;p=a||this.options.generateId?e[t+3]:this.points[e[t+3]].id,void 0!==p&&(u.id=p),i.features.push(u)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:r,reduce:o,minPoints:i}=this.options,n=s/(r*Math.pow(2,e)),a=t.data,h=[],c=this.stride;for(let l=0;l<a.length;l+=c){if(a[l+2]<=e)continue;a[l+2]=e;const s=a[l],r=a[l+1],u=t.within(a[l],a[l+1],n),p=a[l+5];let m=p;for(const t of u){const s=t*c;a[s+2]>e&&(m+=a[s+5])}if(m>p&&m>=i){let t,i=s*p,n=r*p,d=-1;const g=(l/c<<5)+(e+1)+this.points.length;for(const s of u){const r=s*c;if(a[r+2]<=e)continue;a[r+2]=e;const h=a[r+5];i+=a[r]*h,n+=a[r+1]*h,a[r+4]=g,o&&(t||(t=this._map(a,l,!0),d=this.clusterProps.length,this.clusterProps.push(t)),o(t,this._map(a,r)))}a[l+4]=g,h.push(i/m,n/m,1/0,g,-1,m),o&&h.push(d)}else{for(let t=0;t<c;t++)h.push(a[l+t]);if(m>1)for(const t of u){const s=t*c;if(!(a[s+2]<=e)){a[s+2]=e;for(let t=0;t<c;t++)h.push(a[s+t])}}}}return h}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+5]>1){const r=this.clusterProps[t[e+6]];return s?Object.assign({},r):r}const r=this.points[t[e+3]].properties,o=this.options.map(r);return s&&o===r?Object.assign({},o):o}}function f(t,e,s){return{type:"Feature",id:t[e+3],properties:k(t,e,s),geometry:{type:"Point",coordinates:[(r=t[e],360*(r-.5)),x(t[e+1])]}};var r}function k(t,e,s){const r=t[e+5],o=r>=1e4?`${Math.round(r/1e3)}k`:r>=1e3?Math.round(r/100)/10+"k":r,i=t[e+6],n=-1===i?{}:Object.assign({},s[i]);return Object.assign(n,{cluster:!0,cluster_id:t[e+3],point_count:r,point_count_abbreviated:o})}function w(t){return t/360+.5}function y(t){const e=Math.sin(t*Math.PI/180),s=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return s<0?0:s>1?1:s}function x(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function v(t,e){var s={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(s[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(t);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(s[r[o]]=t[r[o]])}return s}class M{static isAdvancedMarkerAvailable(t){return google.maps.marker&&!0===t.getMapCapabilities().isAdvancedMarkersAvailable}static isAdvancedMarker(t){return google.maps.marker&&t instanceof google.maps.marker.AdvancedMarkerElement}static setMap(t,e){this.isAdvancedMarker(t)?t.map=e:t.setMap(e)}static getPosition(t){if(this.isAdvancedMarker(t)){if(t.position){if(t.position instanceof google.maps.LatLng)return t.position;if(t.position.lat&&t.position.lng)return new google.maps.LatLng(t.position.lat,t.position.lng)}return new google.maps.LatLng(null)}return t.getPosition()}static getVisible(t){return!!this.isAdvancedMarker(t)||t.getVisible()}}class P{constructor(t){let{markers:e,position:s}=t;this.markers=e,s&&(s instanceof google.maps.LatLng?this._position=s:this._position=new google.maps.LatLng(s))}get bounds(){if(0===this.markers.length&&!this._position)return;const t=new google.maps.LatLngBounds(this._position,this._position);for(const e of this.markers)t.extend(M.getPosition(e));return t}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter((t=>M.getVisible(t))).length}push(t){this.markers.push(t)}delete(){this.marker&&(M.setMap(this.marker,null),this.marker=void 0),this.markers.length=0}}const C=(t,e,s,r)=>{const o=_(t.getBounds(),e,r);return s.filter((t=>o.contains(M.getPosition(t))))},_=(t,e,s)=>{const{northEast:r,southWest:o}=b(t,e),i=L({northEast:r,southWest:o},s);return Z(i,e)},A=(t,e,s)=>{const r=_(t,e,s),o=r.getNorthEast(),i=r.getSouthWest();return[i.lng(),i.lat(),o.lng(),o.lat()]},E=(t,e)=>{const s=(e.lat-t.lat)*Math.PI/180,r=(e.lng-t.lng)*Math.PI/180,o=Math.sin(s/2),i=Math.sin(r/2),n=o*o+Math.cos(t.lat*Math.PI/180)*Math.cos(e.lat*Math.PI/180)*i*i;return 6371*(2*Math.atan2(Math.sqrt(n),Math.sqrt(1-n)))},b=(t,e)=>({northEast:e.fromLatLngToDivPixel(t.getNorthEast()),southWest:e.fromLatLngToDivPixel(t.getSouthWest())}),L=(t,e)=>{let{northEast:s,southWest:r}=t;return s.x+=e,s.y-=e,r.x-=e,r.y+=e,{northEast:s,southWest:r}},Z=(t,e)=>{let{northEast:s,southWest:r}=t;const o=e.fromDivPixelToLatLng(r),i=e.fromDivPixelToLatLng(s);return new google.maps.LatLngBounds(o,i)};class O{constructor(t){let{maxZoom:e=16}=t;this.maxZoom=e}noop(t){let{markers:e}=t;return T(e)}}class I extends O{constructor(t){var{viewportPadding:e=60}=t;super(v(t,["viewportPadding"])),this.viewportPadding=60,this.viewportPadding=e}calculate(t){let{markers:e,map:s,mapCanvasProjection:r}=t;return s.getZoom()>=this.maxZoom?{clusters:this.noop({markers:e}),changed:!1}:{clusters:this.cluster({markers:C(s,r,e,this.viewportPadding),map:s,mapCanvasProjection:r})}}}const T=t=>t.map((t=>new P({position:M.getPosition(t),markers:[t]})));class S extends I{constructor(t){var{maxDistance:e=4e4,gridSize:s=40}=t;super(v(t,["maxDistance","gridSize"])),this.clusters=[],this.state={zoom:-1},this.maxDistance=e,this.gridSize=s}calculate(t){let{markers:e,map:s,mapCanvasProjection:r}=t;const i={zoom:s.getZoom()};let n=!1;return this.state.zoom>=this.maxZoom&&i.zoom>=this.maxZoom||(n=!o()(this.state,i)),this.state=i,s.getZoom()>=this.maxZoom?{clusters:this.noop({markers:e}),changed:n}:{clusters:this.cluster({markers:C(s,r,e,this.viewportPadding),map:s,mapCanvasProjection:r})}}cluster(t){let{markers:e,map:s,mapCanvasProjection:r}=t;return this.clusters=[],e.forEach((t=>{this.addToClosestCluster(t,s,r)})),this.clusters}addToClosestCluster(t,e,s){let r=this.maxDistance,o=null;for(let i=0;i<this.clusters.length;i++){const e=this.clusters[i],s=E(e.bounds.getCenter().toJSON(),M.getPosition(t).toJSON());s<r&&(r=s,o=e)}if(o&&_(o.bounds,s,this.gridSize).contains(M.getPosition(t)))o.push(t);else{const e=new P({markers:[t]});this.clusters.push(e)}}}class j extends O{constructor(t){super(v(t,[]))}calculate(t){let{markers:e,map:s,mapCanvasProjection:r}=t;return{clusters:this.cluster({markers:e,map:s,mapCanvasProjection:r}),changed:!1}}cluster(t){return this.noop(t)}}class z extends O{constructor(t){var{maxZoom:e,radius:s=60}=t,r=v(t,["maxZoom","radius"]);super({maxZoom:e}),this.state={zoom:-1},this.superCluster=new g(Object.assign({maxZoom:this.maxZoom,radius:s},r))}calculate(t){let e=!1;const s={zoom:t.map.getZoom()};if(!o()(t.markers,this.markers)){e=!0,this.markers=[...t.markers];const s=this.markers.map((t=>{const e=M.getPosition(t);return{type:"Feature",geometry:{type:"Point",coordinates:[e.lng(),e.lat()]},properties:{marker:t}}}));this.superCluster.load(s)}return e||(this.state.zoom<=this.maxZoom||s.zoom<=this.maxZoom)&&(e=!o()(this.state,s)),this.state=s,e&&(this.clusters=this.cluster(t)),{clusters:this.clusters,changed:e}}cluster(t){let{map:e}=t;return this.superCluster.getClusters([-180,-90,180,90],Math.round(e.getZoom())).map((t=>this.transformCluster(t)))}transformCluster(t){let{geometry:{coordinates:[e,s]},properties:r}=t;if(r.cluster)return new P({markers:this.superCluster.getLeaves(r.cluster_id,1/0).map((t=>t.properties.marker)),position:{lat:s,lng:e}});const o=r.marker;return new P({markers:[o],position:M.getPosition(o)})}}class U extends I{constructor(t){var{maxZoom:e,radius:s=60,viewportPadding:r=60}=t,o=v(t,["maxZoom","radius","viewportPadding"]);super({maxZoom:e,viewportPadding:r}),this.superCluster=new g(Object.assign({maxZoom:this.maxZoom,radius:s},o)),this.state={zoom:-1,view:[0,0,0,0]}}calculate(t){const e={zoom:Math.round(t.map.getZoom()),view:A(t.map.getBounds(),t.mapCanvasProjection,this.viewportPadding)};let s=!o()(this.state,e);if(!o()(t.markers,this.markers)){s=!0,this.markers=[...t.markers];const e=this.markers.map((t=>{const e=M.getPosition(t);return{type:"Feature",geometry:{type:"Point",coordinates:[e.lng(),e.lat()]},properties:{marker:t}}}));this.superCluster.load(e)}return s&&(this.clusters=this.cluster(t),this.state=e),{clusters:this.clusters,changed:s}}cluster(t){let{map:e,mapCanvasProjection:s}=t;const r={zoom:Math.round(e.getZoom()),view:A(e.getBounds(),s,this.viewportPadding)};return this.superCluster.getClusters(r.view,r.zoom).map((t=>this.transformCluster(t)))}transformCluster(t){let{geometry:{coordinates:[e,s]},properties:r}=t;if(r.cluster)return new P({markers:this.superCluster.getLeaves(r.cluster_id,1/0).map((t=>t.properties.marker)),position:{lat:s,lng:e}});const o=r.marker;return new P({markers:[o],position:M.getPosition(o)})}}class B{constructor(t,e){this.markers={sum:t.length};const s=e.map((t=>t.count)),r=s.reduce(((t,e)=>t+e),0);this.clusters={count:e.length,markers:{mean:r/e.length,sum:r,min:Math.min(...s),max:Math.max(...s)}}}}class D{render(t,e,s){let{count:r,position:o}=t;const i=`<svg fill="${r>Math.max(10,e.clusters.markers.mean)?"#ff0000":"#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">\n<circle cx="120" cy="120" opacity=".6" r="70" />\n<circle cx="120" cy="120" opacity=".3" r="90" />\n<circle cx="120" cy="120" opacity=".2" r="110" />\n<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${r}</text>\n</svg>`,n=`Cluster of ${r} markers`,a=Number(google.maps.Marker.MAX_ZINDEX)+r;if(M.isAdvancedMarkerAvailable(s)){const t=(new DOMParser).parseFromString(i,"image/svg+xml").documentElement;t.setAttribute("transform","translate(0 25)");const e={map:s,position:o,zIndex:a,title:n,content:t};return new google.maps.marker.AdvancedMarkerElement(e)}const h={position:o,zIndex:a,title:n,icon:{url:`data:image/svg+xml;base64,${btoa(i)}`,anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(h)}}class N{constructor(){!function(t,e){for(let s in e.prototype)t.prototype[s]=e.prototype[s]}(N,google.maps.OverlayView)}}var F;!function(t){t.CLUSTERING_BEGIN="clusteringbegin",t.CLUSTERING_END="clusteringend",t.CLUSTER_CLICK="click"}(F||(F={}));const R=(t,e,s)=>{s.fitBounds(e.bounds)};class $ extends N{constructor(t){let{map:e,markers:s=[],algorithmOptions:r={},algorithm:o=new z(r),renderer:i=new D,onClusterClick:n=R}=t;super(),this.markers=[...s],this.clusters=[],this.algorithm=o,this.renderer=i,this.onClusterClick=n,e&&this.setMap(e)}addMarker(t,e){this.markers.includes(t)||(this.markers.push(t),e||this.render())}addMarkers(t,e){t.forEach((t=>{this.addMarker(t,!0)})),e||this.render()}removeMarker(t,e){const s=this.markers.indexOf(t);return-1!==s&&(M.setMap(t,null),this.markers.splice(s,1),e||this.render(),!0)}removeMarkers(t,e){let s=!1;return t.forEach((t=>{s=this.removeMarker(t,!0)||s})),s&&!e&&this.render(),s}clearMarkers(t){this.markers.length=0,t||this.render()}render(){const t=this.getMap();if(t instanceof google.maps.Map&&t.getProjection()){google.maps.event.trigger(this,F.CLUSTERING_BEGIN,this);const{clusters:e,changed:s}=this.algorithm.calculate({markers:this.markers,map:t,mapCanvasProjection:this.getProjection()});if(s||void 0==s){const t=new Set;for(const r of e)1==r.markers.length&&t.add(r.markers[0]);const s=[];for(const e of this.clusters)null!=e.marker&&(1==e.markers.length?t.has(e.marker)||M.setMap(e.marker,null):s.push(e.marker));this.clusters=e,this.renderClusters(),requestAnimationFrame((()=>s.forEach((t=>M.setMap(t,null)))))}google.maps.event.trigger(this,F.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this)),this.render()}onRemove(){google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach((t=>M.setMap(t,null))),this.clusters.forEach((t=>t.delete())),this.clusters=[]}renderClusters(){const t=new B(this.markers,this.clusters),e=this.getMap();this.clusters.forEach((s=>{1===s.markers.length?s.marker=s.markers[0]:(s.marker=this.renderer.render(s,t,e),s.markers.forEach((t=>M.setMap(t,null))),this.onClusterClick&&s.marker.addListener("click",(t=>{google.maps.event.trigger(this,F.CLUSTER_CLICK,s),this.onClusterClick(t,s,e)}))),M.setMap(s.marker,e)}))}}}}]);
//# sourceMappingURL=237.e7e4f69d.chunk.js.map