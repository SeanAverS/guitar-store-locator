{"version":3,"file":"static/js/455.f7c1365b.chunk.js","mappings":"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","sources":["utils/locationErrorMessages.js","hooks/useTrackLocation.js","utils/fetchStoreData.js","hooks/useNearbyStores.js","utils/debounce.js","icons/GuitarIcon.js","icons/UserIcon.js","utils/customClusterRenderer.js","hooks/useMarkers.js","components/StoreErrorMessages.js","components/Maps.js"],"sourcesContent":["/**\r\n * Returns a specific message based on the Geolocation API's error code.\r\n * @param {number} errorCode - The error code provided by the Geolocation API.\r\n * @returns {string} A user-friendly error message.\r\n * // GeolocationPositionErrors commented out to not rely on window object\r\n */\r\nexport const getLocationErrorMessage = (errorCode) => {\r\n  switch (errorCode) {\r\n    case 1: // GeolocationPositionError.PERMISSION_DENIED\r\n      return \"Location access denied. Please enable your location in the browser.\";\r\n    case 2: // GeolocationPositionError.POSITION_UNAVAILABLE\r\n      return \"Your location information is unavailable. Please check device settings.\";\r\n    case 3: // GeolocationPositionError.TIMEOUT\r\n      return \"Timed out while trying to retrieve your location. Please try again.\";\r\n    default:\r\n      return \"An unknown error occurred while trying to get your location.\";\r\n  }\r\n};","import { useEffect, useState } from \"react\";\r\nimport { getLocationErrorMessage } from \"../utils/locationErrorMessages.js\";\r\n\r\nconst SIGNIFICANT_DISTANCE = 0.005;\r\n\r\n/**\r\n * A hook to get and track the user's location\r\n * @param {function} handleLocationUpdate This handles a users new location\r\n * @returns {{ currentLocation: object, locationError: string }} The user's current location and location errors\r\n */\r\n\r\nconst useTrackLocation = (handleLocationUpdate) => {\r\n  const [currentLocation, setCurrentLocation] = useState(null);\r\n  const [locationError, setLocationError] = useState(null);\r\n\r\n  // do not re-render if new location is not too far from old location\r\n useEffect(() => {\r\n  const significantLocationChange = (newLocation, oldLocation) => {\r\n    const deltaLat = newLocation.lat - oldLocation.lat;\r\n    const deltaLng = newLocation.lng - oldLocation.lng;\r\n    return (\r\n      deltaLat * deltaLat + deltaLng * deltaLng >\r\n      SIGNIFICANT_DISTANCE * SIGNIFICANT_DISTANCE\r\n    );\r\n  };\r\n\r\n  // check geolocation status\r\n    if (!navigator.geolocation) {\r\n      console.error(\"Geolocation not supported.\");\r\n      setLocationError(\r\n        \"Geolocation is not supported by your browser. Please try a different browser or enable location services.\"\r\n      );\r\n      return;\r\n    }\r\n\r\n    // get the user's location \r\n    navigator.geolocation.getCurrentPosition(\r\n      (userPosition) => {\r\n        const newLocation = {\r\n          lat: userPosition.coords.latitude,\r\n          lng: userPosition.coords.longitude,\r\n        };\r\n        if (\r\n          !currentLocation ||\r\n          significantLocationChange(newLocation, currentLocation)\r\n        ) {\r\n          setCurrentLocation(newLocation);\r\n          handleLocationUpdate(userPosition);\r\n          setLocationError(null);\r\n        }\r\n      },\r\n      (error) => {\r\n        console.error(\"Error getting location\", error);\r\n        setLocationError(getLocationErrorMessage(error.code));\r\n      }\r\n    );\r\n  }, [currentLocation, handleLocationUpdate]);\r\n\r\n  return { currentLocation, locationError };\r\n};\r\n\r\nexport default useTrackLocation;","/**\r\n * Handle api requests then validate response\r\n * @param {string} url The endpoint to fetch data from\r\n * @returns {Promise<Array>} Return store data in an array\r\n * @throws {Error} Network response error\r\n */\r\nexport const fetchData = async (url) => {\r\n  const response = await fetch(url);\r\n  if (!response.ok) {\r\n    throw new Error(`HTTP error! status: ${response.status}`);\r\n  }\r\n  const data = await response.json();\r\n  if (!Array.isArray(data)) {\r\n    console.error(`Data fetched from ${url} is not an array`);\r\n    return [];\r\n  }\r\n  return data;\r\n};","import { useCallback, useMemo, useState } from \"react\";\r\nimport { debounce } from \"../utils/debounce.js\";\r\nimport { fetchData } from \"../utils/fetchStoreData.js\";\r\n\r\n/**\r\n * A hook to get stores near the users location\r\n * It provides a loading state for store fetching and error information\r\n * \r\n * @returns {{\r\n * stores: Array,\r\n * storesFetched: boolean,\r\n * fetchNearbyStores: function,\r\n * debouncedFetchNearbyStores: function,\r\n * loading: boolean,\r\n * error: string\r\n * }} contains the states and functions to handle nearby stores\r\n */\r\n\r\n// render backend\r\nconst isDev = window.location.hostname === \"localhost\";\r\nconst BASE_URL = isDev\r\n  ? \"http://localhost:5050\"\r\n  : \"https://guitar-store-locator.onrender.com\";\r\n\r\nconst CACHE_EXPIRATION = 10 * 60 * 1000; // 10 minutes\r\n\r\nconst useNearbyStores = () => {\r\n  const [stores, setStores] = useState([]);\r\n  const [storesFetched, setIsStoresFetched] = useState(false);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  // get nearby stores from google\r\n  const fetchGoogleStoresFromAPI = useCallback(async (location, limit = 10) => {\r\n    const storeUrl = `${BASE_URL}/api/nearbyStores?lat=${location.lat}&lng=${location.lng}&limit=${limit}`;\r\n\r\n    try {\r\n      const data = await fetchData(storeUrl);\r\n\r\n      const googleResults = data.map((store) => ({\r\n        ...store,\r\n        source: \"google\",\r\n      }));\r\n\r\n      const cacheObject = {\r\n        timestamp: Date.now(),\r\n        data: googleResults,\r\n      };\r\n      localStorage.setItem(\"nearbyStores\", JSON.stringify(cacheObject));\r\n      return googleResults;\r\n    } catch (error) {\r\n      console.error(\"Error fetching data from Google API:\", error);\r\n      setError(error.message);\r\n      return [];\r\n    }\r\n  }, []);\r\n\r\n  // get nearby stores from MongoDB\r\n  const fetchMongoStoresFromAPI = useCallback(\r\n    async (location, maxDistance = 5000) => {\r\n      const mongoStoreUrl = `${BASE_URL}/api/stores/nearby?lat=${location.lat}&lng=${location.lng}&maxDistance=${maxDistance}`;\r\n\r\n      try {\r\n        const data = await fetchData(mongoStoreUrl);\r\n        \r\n        // data source\r\n        return data.map((store) => ({ ...store, source: \"mongodb\" }));\r\n      } catch (error) {\r\n        console.error(\"Error fetching data from MongoDB:\", error);\r\n        setError(error.message);\r\n        return [];\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  // get already cached stores or call them from API\r\n  const getGoogleStoresFromCacheOrAPI = useCallback(\r\n    async (location) => {\r\n      const storedData = localStorage.getItem(\"nearbyStores\");\r\n      if (!storedData) {\r\n        return await fetchGoogleStoresFromAPI(location);\r\n      }\r\n\r\n      // get non-expired stores from cache\r\n      try {\r\n        const cacheObject = JSON.parse(storedData);\r\n        if (\r\n          !cacheObject ||\r\n          !Array.isArray(cacheObject.data) ||\r\n          typeof cacheObject.timestamp !== \"number\"\r\n        ) {\r\n          throw new Error(\"Invalid cache format\");\r\n        }\r\n\r\n        const isCacheExpired =\r\n          Date.now() - cacheObject.timestamp > CACHE_EXPIRATION;\r\n        if (isCacheExpired) {\r\n          return await fetchGoogleStoresFromAPI(location);\r\n        }\r\n\r\n        return cacheObject.data;\r\n      } catch (error) {\r\n        console.error(\"Cache validation failed, fetching new data:\", error);\r\n        return await fetchGoogleStoresFromAPI(location);\r\n      }\r\n    },\r\n    [fetchGoogleStoresFromAPI]\r\n  );\r\n\r\n  // get nearby stores from Google and MongoDB\r\n  const fetchNearbyStores = useCallback(\r\n    async (location) => {\r\n      setLoading(true);\r\n      setError(null);\r\n      \r\n      const googleResults = await getGoogleStoresFromCacheOrAPI(location);\r\n      const mongoResults = await fetchMongoStoresFromAPI(location);\r\n\r\n      const uniqueStores = new Map();\r\n\r\n      // Add MongoDB stores first (prevent google overlap)\r\n      mongoResults.forEach((store) => {\r\n        uniqueStores.set(store.placeId, store);\r\n      });\r\n\r\n      // Add Google stores if place_id not in uniqueStores\r\n      googleResults.forEach((store) => {\r\n        if (!uniqueStores.has(store.place_id)) {\r\n          uniqueStores.set(store.place_id, store);\r\n        }\r\n      });\r\n\r\n      setStores(Array.from(uniqueStores.values()));\r\n      setIsStoresFetched(true);\r\n      setLoading(false);\r\n    },\r\n    [fetchMongoStoresFromAPI, getGoogleStoresFromCacheOrAPI]\r\n  );\r\n\r\n  const debouncedFetchNearbyStores = useMemo(\r\n    () => debounce(fetchNearbyStores, 1000),\r\n    [fetchNearbyStores]\r\n  );\r\n\r\n  return {\r\n    stores,\r\n    storesFetched,\r\n    fetchNearbyStores,\r\n    debouncedFetchNearbyStores,\r\n    loading,\r\n    error,\r\n  };\r\n};\r\n\r\nexport default useNearbyStores;\r\n","/**\r\n * Delay function until x amount of time passes\r\n * Used in useNearbyStores.js and Maps.js to prevent too many store fetches\r\n * @param {Function} func - The function to debounce.\r\n * @param {number} wait - X number of milliseonds before function call\r\n * @returns {Function} A debounced version of the function.\r\n */\r\nexport function debounce(func, wait) {\r\n  let timeout;\r\n  return (...args) => {\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => func(...args), wait);\r\n  };\r\n}\r\n","import { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faGuitar } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nconst GuitarIcon = () => (\r\n  <FontAwesomeIcon\r\n    icon={faGuitar}\r\n    size=\"3x\"\r\n    style={{\r\n      color: \"#007bff\",\r\n      cursor: \"pointer\",\r\n    }}\r\n  />\r\n);\r\n\r\nexport default GuitarIcon;\r\n","import { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faPersonRunning } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nconst UserIcon = () => (\r\n  <FontAwesomeIcon\r\n    icon={faPersonRunning}\r\n    size=\"3x\"\r\n    style={{ color: \"black\", cursor: \"default\" }}\r\n  />\r\n);\r\n\r\nexport default UserIcon;\r\n","/**\r\n * Renders a custom marker cluster for the Google Maps Marker Clustering library\r\n * This is used to fix overlapping store markers when zooming in or out.\r\n * @param {object} { count, position } - cluster properties.\r\n * @returns {google.maps.marker.AdvancedMarkerElement} A custom marker.\r\n */\r\nexport const customClusterRenderer = ({ count, position }) => {\r\n  const div = document.createElement(\"div\");\r\n\r\n  div.style.background = \"#007bff\";\r\n  div.style.color = \"#fff\";\r\n  div.style.borderRadius = \"50%\";\r\n  div.style.padding = \"10px\";\r\n  div.style.width = \"10px\";\r\n  div.style.height = \"10px\";\r\n  div.style.display = \"flex\";\r\n  div.style.alignItems = \"center\";\r\n  div.style.justifyContent = \"center\";\r\n\r\n  div.textContent = count;\r\n\r\n  return new window.google.maps.marker.AdvancedMarkerElement({\r\n    position,\r\n    content: div,\r\n  });\r\n};\r\n","import { useCallback } from \"react\";\r\nimport { createRoot } from \"react-dom/client\";\r\nimport GuitarIcon from \"../icons/GuitarIcon.js\";\r\nimport UserIcon from \"../icons/UserIcon.js\";\r\nimport { customClusterRenderer } from \"../utils/customClusterRenderer.js\";\r\nimport { startTransition } from \"react\";\r\n\r\n\r\n/**\r\n * A hook to generate user and store markers on the map\r\n * @param {object} mapRef - keep track of the current maps state\r\n * @param {function} setActiveMarker - handle the state and information of the store being currently clicked\r\n * @returns {{\r\n * loadMarkers: function\r\n * }} An object containing the function that displays all markers on the map\r\n */\r\n\r\nconst loadClusterer = () =>\r\n  import(\"@googlemaps/markerclusterer\").then((mod) => mod.MarkerClusterer);\r\n\r\nconst useMarkers = (mapRef, setActiveMarker) => {\r\n  const loadMarkers = useCallback(\r\n    async (stores, currentLocation) => {\r\n      if (!window.google?.maps || !mapRef.current) {\r\n        console.error(\"Google Maps API is not available.\");\r\n        return;\r\n      }\r\n\r\n      // Clear markers from previous renders\r\n      if (mapRef.current.markers) {\r\n        mapRef.current.markers.forEach((marker) => marker.setMap(null));\r\n      }\r\n\r\n      mapRef.current.markers = [];\r\n\r\n      if (!stores || stores.length === 0) return;\r\n\r\n      // Create markers for nearby stores\r\n      const { AdvancedMarkerElement } = await window.google.maps.importLibrary(\r\n        \"marker\"\r\n      );\r\n\r\n      const storeMarkers = stores.map((store) => {\r\n        const guitarIcon = document.createElement(\"div\");\r\n        createRoot(guitarIcon).render(<GuitarIcon />);\r\n\r\n        // use google or MongoDB data for store location\r\n        let position;\r\n\r\n        if (store.source === \"google\") {\r\n          position = store.geometry.location;\r\n        } else { // MongoDB\r\n          position = {\r\n            lat: store.location.coordinates[1],\r\n            lng: store.location.coordinates[0],\r\n          };\r\n        }\r\n\r\n        const marker = new AdvancedMarkerElement({\r\n          position: position,\r\n          title: store.name,\r\n          content: guitarIcon,\r\n        });\r\n\r\n        // prevent repeat renders of store info\r\n        marker.addListener(\"gmp-click\", () => {\r\n          startTransition(() => {\r\n            setActiveMarker(store);\r\n          });\r\n        });\r\n        return marker;\r\n      });\r\n\r\n      // Cluster nearby stores\r\n      const MarkerClusterer = await loadClusterer();\r\n\r\n      mapRef.current.clusterer = new MarkerClusterer({\r\n        markers: storeMarkers,\r\n        map: mapRef.current,\r\n        renderer: {\r\n          render: customClusterRenderer,\r\n        },\r\n      });\r\n\r\n      // User location marker\r\n      const userIcon = document.createElement(\"div\");\r\n      createRoot(userIcon).render(<UserIcon />);\r\n\r\n      const userMarker = new AdvancedMarkerElement({\r\n        map: mapRef.current,\r\n        position: currentLocation,\r\n        content: userIcon,\r\n      });\r\n\r\n      mapRef.current.markers.push(...storeMarkers, userMarker);\r\n    },\r\n    [mapRef, setActiveMarker]\r\n  );\r\n\r\n  return { loadMarkers };\r\n};\r\n\r\nexport default useMarkers;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n/**\r\n * Display message if stores and/or location can't be found\r\n * @param {object} props - The component's props.\r\n * @param {boolean} props.storesFetched - True if the stores have been fetched.\r\n * @param {array} props.stores - The array of stores.\r\n * @param {string} props.locationError - The error message from the location tracking hook.\r\n * @param {string} props.storesError - The error message from the stores fetching hook.\r\n */\r\n\r\nconst StoreErrorMessages = ({ storesFetched, stores, locationError, storesError }) => {\r\n  if (storesFetched && stores.length === 0 && !locationError && !storesError) {\r\n    return (\r\n      <div className=\"no-stores-found-message\">\r\n        No stores found near your location. Try adjusting your location or checking back later.\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (storesError) {\r\n    return (\r\n      <div className=\"stores-fetched-error-message\">\r\n        <p>Error fetching stores: {storesError}. Please try again later.</p>\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  return null;\r\n};\r\n\r\nStoreErrorMessages.propTypes = {\r\n  storesFetched: PropTypes.bool.isRequired,\r\n  stores: PropTypes.array.isRequired,\r\n  locationError: PropTypes.string,\r\n  storesError: PropTypes.string,\r\n};\r\n\r\nexport default StoreErrorMessages;","import { useState, useCallback, useRef, useEffect, useMemo, lazy } from \"react\";\r\nimport { useJsApiLoader } from \"@react-google-maps/api\";\r\nimport \"../index.css\";\r\nimport useTrackLocation from \"../hooks/useTrackLocation.js\";\r\nimport useNearbyStores from \"../hooks/useNearbyStores.js\";\r\nimport useMarkers from \"../hooks/useMarkers.js\";\r\nimport StoreErrorMessages from \"./StoreErrorMessages.js\";\r\n\r\n/**\r\n * The main component for the Guitar Store Locator application.\r\n * This component: \r\n * loads the google map\r\n * tracks the users location\r\n * gets nearby stores and displays them on the map\r\n * integrates multiple hooks to handle all the necessary logic.\r\n */\r\n\r\nconst MapContainer = lazy(() => import(\"../components/MapContainer.js\"));\r\nconst InfoWindowCard = lazy(() => import(\"../components/InfoWindowCard.js\"));\r\n\r\nconst googleMapsLibraries = [\"places\", \"marker\"];\r\n\r\nconst Maps = () => {\r\n  const loaderOptions = useMemo(\r\n    () => ({\r\n      googleMapsApiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY,\r\n      libraries: googleMapsLibraries,\r\n      mapId: process.env.REACT_APP_MAP_ID,\r\n    }),\r\n    []\r\n  );\r\n  const { isLoaded, loadError } = useJsApiLoader(loaderOptions);\r\n\r\n  const mapRef = useRef(null);\r\n  \r\n  const [activeMarker, setActiveMarker] = useState(null);\r\n\r\n  const {\r\n    stores,\r\n    storesFetched,\r\n    fetchNearbyStores,\r\n    debouncedFetchNearbyStores,\r\n    error: storesError,\r\n  } = useNearbyStores();\r\n\r\n  // get new nearby stores if user location changes\r\n  const handleLocationUpdate = useCallback(\r\n    (userPosition) => {\r\n      const newLocation = {\r\n        lat: userPosition.coords.latitude,\r\n        lng: userPosition.coords.longitude,\r\n      };\r\n      debouncedFetchNearbyStores(newLocation);\r\n    },\r\n    [debouncedFetchNearbyStores]\r\n  );\r\n  const { currentLocation, locationError } = useTrackLocation(\r\n    handleLocationUpdate\r\n  );\r\n\r\n  // get nearby stores when user location changes\r\n  useEffect(() => {\r\n    if (isLoaded && currentLocation && !storesFetched && !storesError) {\r\n      fetchNearbyStores(currentLocation);\r\n    }\r\n  }, [\r\n    isLoaded,\r\n    currentLocation,\r\n    storesFetched,\r\n    fetchNearbyStores,\r\n    storesError,\r\n  ]);\r\n\r\n  // show stores on map based on user location\r\n  const { loadMarkers } = useMarkers(mapRef, setActiveMarker);\r\n  useEffect(() => {\r\n    if (isLoaded && mapRef.current && stores.length > 0 && currentLocation) {\r\n      loadMarkers(stores, currentLocation);\r\n    }\r\n  }, [isLoaded, stores, currentLocation, loadMarkers]);\r\n\r\n  // pan to user whenever their location changes\r\n  useEffect(() => {\r\n    if (currentLocation && mapRef.current) {\r\n      mapRef.current.panTo(currentLocation);\r\n    }\r\n  }, [currentLocation]);\r\n\r\n  // google maps directions\r\n  const generateDirectionsUrl = useCallback(() => {\r\n    if (!activeMarker || !currentLocation) {\r\n      return \"#\";\r\n    }\r\n\r\n    let lat, lng;\r\n\r\n    // format Google or MongoDB coordinates\r\n    if (activeMarker.geometry && activeMarker.geometry.location) { // Google\r\n      lat = activeMarker.geometry.location.lat;\r\n      lng = activeMarker.geometry.location.lng;\r\n    }\r\n    else if (activeMarker.location && activeMarker.location.coordinates) { // MongoDB\r\n      lat = activeMarker.location.coordinates[1];\r\n      lng = activeMarker.location.coordinates[0];\r\n    } else {\r\n      return \"#\";\r\n    }\r\n\r\n    // redirect to google maps directions\r\n    const userLocation = `${currentLocation.lat},${currentLocation.lng}`;\r\n    const guitarStore = `${lat},${lng}`;\r\n    \r\n    return `https://www.google.com/maps/dir/?api=1&origin=${userLocation}&destination=${guitarStore}&destination_place_id=${activeMarker.place_id}&destination_name=${encodeURIComponent(activeMarker.name)}&travelmode=driving`;\r\n  }, [activeMarker, currentLocation]);\r\n\r\n  // map loading errors\r\n  if (loadError) return null;\r\n  if (!isLoaded) return null;\r\n\r\n  return (\r\n    <>\r\n       <StoreErrorMessages\r\n      storesFetched={storesFetched}\r\n      stores={stores}\r\n      locationError={locationError}\r\n      storesError={storesError}\r\n    />\r\n      <MapContainer\r\n        mapRef={mapRef}\r\n        currentLocation={currentLocation}\r\n      >\r\n        {activeMarker && (\r\n          <InfoWindowCard\r\n            marker={activeMarker}\r\n            directionsUrl={generateDirectionsUrl()}\r\n            onClose={() => setActiveMarker(null)}\r\n          />\r\n        )}\r\n      </MapContainer>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Maps;\r\n"],"names":["handleLocationUpdate","currentLocation","setCurrentLocation","useState","locationError","setLocationError","useEffect","navigator","geolocation","console","error","getCurrentPosition","userPosition","newLocation","lat","coords","latitude","lng","longitude","significantLocationChange","oldLocation","deltaLat","deltaLng","SIGNIFICANT_DISTANCE","errorCode","getLocationErrorMessage","code","fetchData","async","response","fetch","url","ok","Error","status","data","json","Array","isArray","BASE_URL","window","location","hostname","useNearbyStores","stores","setStores","storesFetched","setIsStoresFetched","loading","setLoading","setError","fetchGoogleStoresFromAPI","useCallback","limit","arguments","length","undefined","storeUrl","googleResults","map","store","source","cacheObject","timestamp","Date","now","localStorage","setItem","JSON","stringify","message","fetchMongoStoresFromAPI","maxDistance","mongoStoreUrl","getGoogleStoresFromCacheOrAPI","storedData","getItem","parse","fetchNearbyStores","mongoResults","uniqueStores","Map","forEach","set","placeId","has","place_id","from","values","debouncedFetchNearbyStores","useMemo","func","wait","timeout","_len","args","_key","clearTimeout","setTimeout","debounce","GuitarIcon","_jsx","FontAwesomeIcon","icon","faGuitar","size","style","color","cursor","UserIcon","faPersonRunning","customClusterRenderer","_ref","count","position","div","document","createElement","background","borderRadius","padding","width","height","display","alignItems","justifyContent","textContent","google","maps","marker","AdvancedMarkerElement","content","useMarkers","mapRef","setActiveMarker","loadMarkers","_window$google","current","markers","setMap","importLibrary","storeMarkers","guitarIcon","createRoot","render","geometry","coordinates","title","name","addListener","startTransition","MarkerClusterer","then","mod","clusterer","renderer","userIcon","userMarker","push","storesError","className","children","_jsxs","MapContainer","lazy","InfoWindowCard","googleMapsLibraries","Maps","loaderOptions","googleMapsApiKey","process","libraries","mapId","isLoaded","loadError","useJsApiLoader","useRef","activeMarker","useTrackLocation","panTo","generateDirectionsUrl","encodeURIComponent","_Fragment","StoreErrorMessages","directionsUrl","onClose"],"sourceRoot":""}